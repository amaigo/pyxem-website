
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pyxem.utils package &#8212; pyxem 0.8.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="pyxem-utils-package">
<h1>pyxem.utils package<a class="headerlink" href="#pyxem-utils-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyxem.utils.atomic_scattering_params">
<span id="pyxem-utils-atomic-scattering-params-module"></span><h2>pyxem.utils.atomic_scattering_params module<a class="headerlink" href="#module-pyxem.utils.atomic_scattering_params" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyxem.utils.expt_utils">
<span id="pyxem-utils-expt-utils-module"></span><h2>pyxem.utils.expt_utils module<a class="headerlink" href="#module-pyxem.utils.expt_utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.expt_utils.affine_transformation">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">affine_transformation</code><span class="sig-paren">(</span><em>z</em>, <em>transformation</em>, <em>order</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.affine_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an affine transformation to a 2-dimensional array.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array</span></dt><dd><p>Array to be transformed</p>
</dd>
<dt>matrix<span class="classifier">np.array</span></dt><dd><p>3x3 numpy array specifying the affine transformation to be applied.</p>
</dd>
<dt>order<span class="classifier">int</span></dt><dd><p>Interpolation order.</p>
</dd>
<dt><a href="#id1"><span class="problematic" id="id2">*</span></a>args :</dt><dd><p>To be passed to skimage.warp</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs :</dt><dd><p>To be passed to skimage.warp</p>
</dd>
</dl>
<dl class="simple">
<dt>trans<span class="classifier">array</span></dt><dd><p>Affine transformed diffraction pattern.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.circular_mask">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">circular_mask</code><span class="sig-paren">(</span><em>shape</em>, <em>radius</em>, <em>center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.circular_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a mask of radius ‘r’ centered on ‘center’ of shape ‘shape’.</p>
<dl class="simple">
<dt>shape<span class="classifier">tuple</span></dt><dd><p>The shape of the signal to be masked.</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>The radius of the circular mask.</p>
</dd>
<dt>center<span class="classifier">tuple (optional)</span></dt><dd><p>The center of the circular mask. Default: (0, 0)</p>
</dd>
</dl>
<dl class="simple">
<dt>mask<span class="classifier">np.array()</span></dt><dd><p>The circular mask.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.find_beam_offset_cross_correlation">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">find_beam_offset_cross_correlation</code><span class="sig-paren">(</span><em>z</em>, <em>radius_start=4</em>, <em>radius_finish=8</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.find_beam_offset_cross_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to center the direct beam center by a cross-correlation algorithm.
The shift is calculated relative to an circle perimeter. The circle can be
refined across a range of radii during the centring procedure to improve
performance in regions where the direct beam size changes,
e.g. during sample thickness variation.</p>
<dl class="simple">
<dt>radius_start<span class="classifier">int</span></dt><dd><p>The lower bound for the radius of the central disc to be used in the
alignment.</p>
</dd>
<dt>radius_finish<span class="classifier">int</span></dt><dd><p>The upper bounds for the radius of the central disc to be used in the
alignment.</p>
</dd>
</dl>
<dl class="simple">
<dt>shift: np.array</dt><dd><p>np.array containing offset (from center) of the direct beam positon.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.gain_normalise">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">gain_normalise</code><span class="sig-paren">(</span><em>z</em>, <em>dref</em>, <em>bref</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.gain_normalise" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply gain normalization to experimentally acquired electron
diffraction pattern.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Two-dimensional data array containing signal.</p>
</dd>
<dt>dref<span class="classifier">ElectronDiffraction</span></dt><dd><p>Two-dimensional data array containing dark reference.</p>
</dd>
<dt>bref<span class="classifier">ElectronDiffraction</span></dt><dd><p>Two-dimensional data array containing bright reference.</p>
</dd>
</dl>
<dl class="simple">
<dt>z1<span class="classifier">np.array()</span></dt><dd><p>Two dimensional data array of gain normalized z.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.peaks_as_gvectors">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">peaks_as_gvectors</code><span class="sig-paren">(</span><em>z</em>, <em>center</em>, <em>calibration</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.peaks_as_gvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts peaks found as array indices to calibrated units, for use in a
hyperspy map function.</p>
<dl class="simple">
<dt>z<span class="classifier">numpy array</span></dt><dd><p>peak postitions as array indices.</p>
</dd>
<dt>center<span class="classifier">numpy array</span></dt><dd><p>diffraction pattern center in array indices.</p>
</dd>
<dt>calibration<span class="classifier">float</span></dt><dd><p>calibration in reciprocal Angstroms per pixels.</p>
</dd>
</dl>
<dl class="simple">
<dt>g<span class="classifier">numpy array</span></dt><dd><p>peak positions in calibrated units.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.radial_average">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">radial_average</code><span class="sig-paren">(</span><em>z</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.radial_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the radial profile by azimuthal averaging about a specified
center.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Two-dimensional data array containing signal.</p>
</dd>
<dt>mask<span class="classifier">np.array()</span></dt><dd><p>Array with the same dimensions as z comprizing 0s for excluded pixels
and 1s for non-excluded pixels.</p>
</dd>
</dl>
<dl class="simple">
<dt>radial_profile<span class="classifier">np.array()</span></dt><dd><p>One-dimensional radial profile of z.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.reference_circle">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">reference_circle</code><span class="sig-paren">(</span><em>coords</em>, <em>dimX</em>, <em>dimY</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.reference_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the perimeter of an circle at a given position in the diffraction
pattern (e.g. to provide a reference for finding the direct beam center).</p>
<dl class="simple">
<dt>coords<span class="classifier">np.array size n,2</span></dt><dd><p>size n,2 array of coordinates to draw the circle.</p>
</dd>
<dt>dimX<span class="classifier">int</span></dt><dd><p>first dimension of the diffraction pattern (size)</p>
</dd>
<dt>dimY<span class="classifier">int</span></dt><dd><p>second dimension of the diffraction pattern (size)</p>
</dd>
<dt>radius<span class="classifier">int</span></dt><dd><p>radius of the circle to be drawn</p>
</dd>
</dl>
<dl class="simple">
<dt>img: np.array</dt><dd><p>Array containing the circle at the position given in the coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.regional_filter">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">regional_filter</code><span class="sig-paren">(</span><em>z</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.regional_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a h-dome regional filtering of the an image for background
subtraction.</p>
<dl class="simple">
<dt>h<span class="classifier">float</span></dt><dd><p>h-dome cutoff value.</p>
</dd>
</dl>
<blockquote>
<div><p>h-dome subtracted image as np.array</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.remove_dead">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">remove_dead</code><span class="sig-paren">(</span><em>z</em>, <em>deadpixels</em>, <em>deadvalue='average'</em>, <em>d=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.remove_dead" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove dead pixels from experimental electron diffraction patterns.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Two-dimensional data array containing signal.</p>
</dd>
<dt>deadpixels<span class="classifier">np.array()</span></dt><dd><p>Array containing the array indices of dead pixels in the diffraction
pattern.</p>
</dd>
<dt>deadvalue<span class="classifier">string</span></dt><dd><dl class="simple">
<dt>Specify how deadpixels should be treated, options are;</dt><dd><p>‘average’: takes the average of adjacent pixels
‘nan’:  sets the dead pixel to nan</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple">
<dt>img<span class="classifier">array</span></dt><dd><p>Two-dimensional data array containing z with dead pixels removed.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.subtract_background_dog">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">subtract_background_dog</code><span class="sig-paren">(</span><em>z</em>, <em>sigma_min</em>, <em>sigma_max</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.subtract_background_dog" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference of gaussians method for background removal.</p>
<dl class="simple">
<dt>sigma_max<span class="classifier">float</span></dt><dd><p>Large gaussian blur sigma.</p>
</dd>
<dt>sigma_min<span class="classifier">float</span></dt><dd><p>Small gaussian blur sigma.</p>
</dd>
</dl>
<blockquote>
<div><p>Denoised diffraction pattern as np.array</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.subtract_background_median">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">subtract_background_median</code><span class="sig-paren">(</span><em>z</em>, <em>footprint=19</em>, <em>implementation='scipy'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.subtract_background_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove background using a median filter.</p>
<dl class="simple">
<dt>footprint<span class="classifier">int</span></dt><dd><p>size of the window that is convoluted with the array to determine
the median. Should be large enough that it is about 3x as big as the
size of the peaks.</p>
</dd>
<dt>implementation: str</dt><dd><p>One of ‘scipy’, ‘skimage’. Skimage is much faster, but it messes with
the data format. The scipy implementation is safer, but slower.</p>
</dd>
</dl>
<blockquote>
<div><p>Pattern with background subtracted as np.array</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.expt_utils.subtract_reference">
<code class="descclassname">pyxem.utils.expt_utils.</code><code class="descname">subtract_reference</code><span class="sig-paren">(</span><em>z</em>, <em>bg</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.expt_utils.subtract_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts background using a user-defined background pattern.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Two-dimensional data array containing signal.</p>
</dd>
<dt>bg: array()</dt><dd><p>User-defined diffraction pattern to be subtracted as background.</p>
</dd>
</dl>
<dl class="simple">
<dt>im<span class="classifier">np.array()</span></dt><dd><p>Two-dimensional data array containing signal with background removed.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.indexation_utils">
<span id="pyxem-utils-indexation-utils-module"></span><h2>pyxem.utils.indexation_utils module<a class="headerlink" href="#module-pyxem.utils.indexation_utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.indexation_utils.correlate_library">
<code class="descclassname">pyxem.utils.indexation_utils.</code><code class="descname">correlate_library</code><span class="sig-paren">(</span><em>image</em>, <em>library</em>, <em>n_largest</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.indexation_utils.correlate_library" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlates all simulated diffraction templates in a DiffractionLibrary
with a particular experimental diffraction pattern (image).</p>
<p>Calculated using the normalised (see return type documentation) dot
product, or cosine distance,</p>
<div class="math notranslate nohighlight">
\[\frac{\sum_{j=1}^m P(x_j, y_j) T(x_j, y_j)}{\sqrt{\sum_{j=1}^m T^2(x_j, y_j)}}\]</div>
<p>for a template T and an experimental pattern P.</p>
<dl class="simple">
<dt>image<span class="classifier">numpy.array</span></dt><dd><p>The experimental diffraction pattern of interest.</p>
</dd>
<dt>library<span class="classifier">DiffractionLibrary</span></dt><dd><p>The library of diffraction simulations to be correlated with the
experimental data.</p>
</dd>
<dt>n_largest<span class="classifier">int</span></dt><dd><p>The number of well correlated simulations to be retained.</p>
</dd>
<dt>mask<span class="classifier">bool</span></dt><dd><p>A mask for navigation axes. 1 indicates positions to be indexed.</p>
</dd>
</dl>
<dl class="simple">
<dt>top_matches<span class="classifier">numpy.array</span></dt><dd><p>Array of shape (&lt;num phases&gt;*n_largest, 3) containing the top n
correlated simulations for the experimental pattern of interest, where
each entry is on the form [phase index, [z, x, z], correlation].</p>
</dd>
</dl>
<p>IndexationGenerator.correlate</p>
<dl class="simple">
<dt>Correlation results are defined as,</dt><dd><dl class="simple">
<dt>phase_index<span class="classifier">int</span></dt><dd><p>Index of the phase, following the ordering of the library keys</p>
</dd>
<dt>[z, x, z]<span class="classifier">ndarray</span></dt><dd><p>numpy array of three floats, specifying the orientation in the
Bunge convention, in degrees.</p>
</dd>
<dt>correlation<span class="classifier">float</span></dt><dd><p>A coefficient of correlation, only normalised to the template
intensity. This is in contrast to the reference work.</p>
</dd>
</dl>
</dd>
</dl>
<ol class="upperalpha simple" start="5">
<li><p>F. Rauch and L. Dupuy, “Rapid Diffraction Patterns identification through
template matching,” vol. 50, no. 1, pp. 87–99, 2005.</p></li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.indexation_utils.crystal_from_template_matching">
<code class="descclassname">pyxem.utils.indexation_utils.</code><code class="descname">crystal_from_template_matching</code><span class="sig-paren">(</span><em>z_matches</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.indexation_utils.crystal_from_template_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes template matching results for a single navigation position and
returns the best matching phase and orientation with correlation and
reliability to define a crystallographic map.</p>
<dl class="simple">
<dt>z_matches<span class="classifier">numpy.array</span></dt><dd><p>Template matching results in an array of shape (m,3) sorted by
correlation (descending) within each phase, with entries
[phase, [z, x, z], correlation]</p>
</dd>
</dl>
<dl class="simple">
<dt>results_array<span class="classifier">numpy.array</span></dt><dd><p>Crystallographic mapping results in an array of shape (3) with entries
[phase, np.array((z, x, z)), dict(metrics)]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.indexation_utils.crystal_from_vector_matching">
<code class="descclassname">pyxem.utils.indexation_utils.</code><code class="descname">crystal_from_vector_matching</code><span class="sig-paren">(</span><em>z_matches</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.indexation_utils.crystal_from_vector_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes vector matching results for a single navigation position and
returns the best matching phase and orientation with correlation and
reliability to define a crystallographic map.</p>
<dl class="simple">
<dt>z_matches<span class="classifier">numpy.array</span></dt><dd><p>Template matching results in an array of shape (m,5) sorted by
total_error (ascending) within each phase, with entries
[phase, R, match_rate, ehkls, total_error]</p>
</dd>
</dl>
<dl class="simple">
<dt>results_array<span class="classifier">numpy.array</span></dt><dd><p>Crystallographic mapping results in an array of shape (3) with entries
[phase, np.array((z, x, z)), dict(metrics)]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.indexation_utils.index_magnitudes">
<code class="descclassname">pyxem.utils.indexation_utils.</code><code class="descname">index_magnitudes</code><span class="sig-paren">(</span><em>z</em>, <em>simulation</em>, <em>tolerance</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.indexation_utils.index_magnitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns hkl indices to peaks in the diffraction profile.</p>
<dl class="simple">
<dt>simulation<span class="classifier">DiffractionProfileSimulation</span></dt><dd><p>Simulation of the diffraction profile.</p>
</dd>
<dt>tolerance<span class="classifier">float</span></dt><dd><p>The n orientations with the highest correlation values are returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>indexation<span class="classifier">np.array()</span></dt><dd><p>indexation results.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.indexation_utils.match_vectors">
<code class="descclassname">pyxem.utils.indexation_utils.</code><code class="descname">match_vectors</code><span class="sig-paren">(</span><em>peaks</em>, <em>library</em>, <em>mag_tol</em>, <em>angle_tol</em>, <em>index_error_tol</em>, <em>n_peaks_to_index</em>, <em>n_best</em>, <em>keys=[]</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.indexation_utils.match_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns hkl indices to pairs of diffraction vectors.</p>
<dl class="simple">
<dt>peaks<span class="classifier">np.array()</span></dt><dd><p>The experimentally measured diffraction vectors, associated with a
particular probe position, to be indexed. In Cartesian coordinates.</p>
</dd>
<dt>library<span class="classifier">VectorLibrary</span></dt><dd><p>Library of reciprocal space vectors to be matched to the vectors.</p>
</dd>
<dt>mag_tol<span class="classifier">float</span></dt><dd><p>Max allowed magnitude difference when comparing vectors.</p>
</dd>
<dt>angle_tol<span class="classifier">float</span></dt><dd><p>Max allowed angle difference in radians when comparing vector pairs.</p>
</dd>
<dt>index_error_tol<span class="classifier">float</span></dt><dd><p>Max allowed error in peak indexation for classifying it as indexed,
calculated as <span class="math notranslate nohighlight">\(|hkl_calculated - round(hkl_calculated)|\)</span>.</p>
</dd>
<dt>n_peaks_to_index<span class="classifier">int</span></dt><dd><p>The maximum number of peak to index.</p>
</dd>
<dt>n_best<span class="classifier">int</span></dt><dd><p>The maximum number of good solutions to be retained.</p>
</dd>
</dl>
<dl class="simple">
<dt>indexation<span class="classifier">np.array()</span></dt><dd><dl class="simple">
<dt>A numpy array containing the indexation results, each result consisting of 5 entries:</dt><dd><p>[phase index, rotation matrix, match rate, error hkls, total error]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.lobato_scattering_params">
<span id="pyxem-utils-lobato-scattering-params-module"></span><h2>pyxem.utils.lobato_scattering_params module<a class="headerlink" href="#module-pyxem.utils.lobato_scattering_params" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pyxem.utils.peakfinder2D_gui">
<span id="pyxem-utils-peakfinder2d-gui-module"></span><h2>pyxem.utils.peakfinder2D_gui module<a class="headerlink" href="#module-pyxem.utils.peakfinder2D_gui" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase">
<em class="property">class </em><code class="descclassname">pyxem.utils.peakfinder2D_gui.</code><code class="descname">PeakFinderUIBase</code><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.current_method">
<code class="descname">current_method</code><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.current_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.get_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.get_peaks">
<code class="descname">get_peaks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.get_peaks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.init_ui">
<code class="descname">init_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.init_ui" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.interactive">
<code class="descname">interactive</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase.interactive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW">
<em class="property">class </em><code class="descclassname">pyxem.utils.peakfinder2D_gui.</code><code class="descname">PeakFinderUIIPYW</code><span class="sig-paren">(</span><em>disc_image=None</em>, <em>imshow_kwargs={}</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIBase" title="pyxem.utils.peakfinder2D_gui.PeakFinderUIBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyxem.utils.peakfinder2D_gui.PeakFinderUIBase</span></code></a></p>
<p>Find peaks using a Jupyter notebook-based user interface</p>
<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_choices_widget">
<code class="descname">create_choices_widget</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_choices_widget" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_navigator">
<code class="descname">create_navigator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_navigator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_navigator_1d">
<code class="descname">create_navigator_1d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_navigator_1d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_navigator_2d">
<code class="descname">create_navigator_2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_navigator_2d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_param_widget">
<code class="descname">create_param_widget</code><span class="sig-paren">(</span><em>param</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_param_widget" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_param_widgets">
<code class="descname">create_param_widgets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.create_param_widgets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.init_ui">
<code class="descname">init_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.init_ui" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.plot_image">
<code class="descname">plot_image</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.plot_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.plot_peaks">
<code class="descname">plot_peaks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.plot_peaks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.replot_image">
<code class="descname">replot_image</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.replot_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.replot_peaks">
<code class="descname">replot_peaks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinder2D_gui.PeakFinderUIIPYW.replot_peaks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.peakfinders2D">
<span id="pyxem-utils-peakfinders2d-module"></span><h2>pyxem.utils.peakfinders2D module<a class="headerlink" href="#module-pyxem.utils.peakfinders2D" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.peakfinders2D.clean_peaks">
<code class="descclassname">pyxem.utils.peakfinders2D.</code><code class="descname">clean_peaks</code><span class="sig-paren">(</span><em>peaks</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinders2D.clean_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to deal with no peaks being found.</p>
<dl class="simple">
<dt>peaks<span class="classifier">numpy.ndarray</span></dt><dd><p>Result of peak finding</p>
</dd>
</dl>
<dl class="simple">
<dt>peaks<span class="classifier">numpy.ndarray</span></dt><dd><p>Result of peak finding</p>
</dd>
<dt>NO_PEAKS<span class="classifier">string</span></dt><dd><p>Flag indicating no peaks found.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.peakfinders2D.find_peaks_dog">
<code class="descclassname">pyxem.utils.peakfinders2D.</code><code class="descname">find_peaks_dog</code><span class="sig-paren">(</span><em>z</em>, <em>min_sigma=1.0</em>, <em>max_sigma=50.0</em>, <em>sigma_ratio=1.6</em>, <em>threshold=0.2</em>, <em>overlap=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinders2D.find_peaks_dog" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds peaks via the difference of Gaussian Matrices method from
<cite>scikit-image</cite>.</p>
<dl class="simple">
<dt>z<span class="classifier">numpy.ndarray</span></dt><dd><p>2-d array of intensities</p>
</dd>
<dt>float min_sigma, max_sigma, sigma_ratio, threshold, overlap</dt><dd><p>Additional parameters to be passed to the algorithm. See <cite>blob_dog</cite>
documentation for details:
<a class="reference external" href="http://scikit-image.org/docs/dev/api/skimage.feature.html#blob-dog">http://scikit-image.org/docs/dev/api/skimage.feature.html#blob-dog</a></p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Array of peak coordinates of shape <cite>(n_peaks, 2)</cite></p>
</dd>
</dl>
<p>While highly effective at finding even very faint peaks, this method is
sensitive to fluctuations in intensity near the edges of the image.</p>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.peakfinders2D.find_peaks_log">
<code class="descclassname">pyxem.utils.peakfinders2D.</code><code class="descname">find_peaks_log</code><span class="sig-paren">(</span><em>z</em>, <em>min_sigma=1.0</em>, <em>max_sigma=50.0</em>, <em>num_sigma=10.0</em>, <em>threshold=0.2</em>, <em>overlap=0.5</em>, <em>log_scale=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinders2D.find_peaks_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds peaks via the Laplacian of Gaussian Matrices method from
<cite>scikit-image</cite>.</p>
<dl class="simple">
<dt>z<span class="classifier">numpy.ndarray</span></dt><dd><p>Array of image intensities.</p>
</dd>
<dt>float min_sigma, max_sigma, num_sigma, threshold, overlap, log_scale</dt><dd><p>Additional parameters to be passed to the algorithm. See
<cite>blob_log</cite> documentation for details:
<a class="reference external" href="http://scikit-image.org/docs/dev/api/skimage.feature.html#blob-log">http://scikit-image.org/docs/dev/api/skimage.feature.html#blob-log</a></p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>(n_peaks, 2)
Array of peak coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.peakfinders2D.find_peaks_stat">
<code class="descclassname">pyxem.utils.peakfinders2D.</code><code class="descname">find_peaks_stat</code><span class="sig-paren">(</span><em>z</em>, <em>alpha=1.0</em>, <em>window_radius=10</em>, <em>convergence_ratio=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinders2D.find_peaks_stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate positive peaks in an image based on statistical refinement and
difference with respect to mean intensity.</p>
<dl class="simple">
<dt>z<span class="classifier">numpy.ndarray</span></dt><dd><p>Array of image intensities.</p>
</dd>
<dt>alpha<span class="classifier">float</span></dt><dd><p>Only maxima above <cite>alpha * sigma</cite> are found, where <cite>sigma</cite> is the
local, rolling standard deviation of the image.</p>
</dd>
<dt>window_radius<span class="classifier">int</span></dt><dd><p>The pixel radius of the circular window for the calculation of the
rolling mean and standard deviation.</p>
</dd>
<dt>convergence_ratio<span class="classifier">float</span></dt><dd><p>The algorithm will stop finding peaks when the proportion of new peaks
being found is less than <cite>convergence_ratio</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>(n_peaks, 2)
Array of peak coordinates.</p>
</dd>
</dl>
<p>Implemented as described in the PhD thesis of Thomas White (2009) the
algorithm was developed by Gordon Ball during a summer project in
Cambridge.
This version by Ben Martineau (2016), with minor modifications to the
original where methods were ambiguous or unclear.</p>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.peakfinders2D.find_peaks_xc">
<code class="descclassname">pyxem.utils.peakfinders2D.</code><code class="descname">find_peaks_xc</code><span class="sig-paren">(</span><em>z</em>, <em>disc_image</em>, <em>min_distance=5</em>, <em>peak_threshold=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinders2D.find_peaks_xc" title="Permalink to this definition">¶</a></dt>
<dd><p>Find peaks using the the correlation between the image and a reference peaks</p>
<dl class="simple">
<dt>z: numpy.ndarray</dt><dd><p>Array of image intensities.</p>
</dd>
<dt>disc_image: numpy.ndarray (square)</dt><dd><p>Array containing a single bright disc, similar to those to detect.</p>
</dd>
<dt>min_distance: int</dt><dd><p>The minimum expected distance between peaks (in pixels)</p>
</dd>
<dt>peak_threshold: float between 0 and 1</dt><dd><p>Larger values will lead to fewer peaks in the output.</p>
</dd>
</dl>
<dl class="simple">
<dt>numpy.ndarray</dt><dd><p>(n_peaks, 2)
Array of peak coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.peakfinders2D.find_peaks_zaefferer">
<code class="descclassname">pyxem.utils.peakfinders2D.</code><code class="descname">find_peaks_zaefferer</code><span class="sig-paren">(</span><em>z</em>, <em>grad_threshold=0.1</em>, <em>window_size=40</em>, <em>distance_cutoff=50.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.peakfinders2D.find_peaks_zaefferer" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to locate positive peaks in an image based on gradient
thresholding and subsequent refinement within masked regions.</p>
<dl class="simple">
<dt>z<span class="classifier">numpy.ndarray</span></dt><dd><p>Matrix of image intensities.</p>
</dd>
<dt>grad_threshold<span class="classifier">float</span></dt><dd><p>The minimum gradient required to begin a peak search.</p>
</dd>
<dt>window_size<span class="classifier">int</span></dt><dd><p>The size of the square window within which a peak search is
conducted. If odd, will round down to even.</p>
</dd>
<dt>distance_cutoff<span class="classifier">float</span></dt><dd><p>The maximum distance a peak may be from the initial
high-gradient point.</p>
</dd>
</dl>
<dl class="simple">
<dt>peaks<span class="classifier">numpy.ndarray</span></dt><dd><p>(n_peaks, 2)
Peak pixel coordinates.</p>
</dd>
</dl>
<p>Implemented as described in Zaefferer “New developments of computer-aided
crystallographic analysis in transmission electron microscopy” J. Ap. Cryst.
This version by Ben Martineau (2016)</p>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.plot">
<span id="pyxem-utils-plot-module"></span><h2>pyxem.utils.plot module<a class="headerlink" href="#module-pyxem.utils.plot" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.plot.generate_marker_inputs_from_peaks">
<code class="descclassname">pyxem.utils.plot.</code><code class="descname">generate_marker_inputs_from_peaks</code><span class="sig-paren">(</span><em>peaks</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.plot.generate_marker_inputs_from_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a peaks (defined in 2D) object from a STEM (more than 1 image) scan
and returns markers.</p>
<dl>
<dt>peaks<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyxem.diffraction_vectors.DiffractionVectors</span></code></span></dt><dd><p>Identifies peaks in a diffraction signal.</p>
</dd>
</dl>
<p>How to get these onto images:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mmx</span><span class="p">,</span><span class="n">mmy</span> <span class="o">=</span> <span class="n">generate_marker_inputs_from_peaks</span><span class="p">(</span><span class="n">found_peaks</span><span class="p">)</span>
<span class="n">dp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mmx</span><span class="p">,</span><span class="n">mmy</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">mx</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">my</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">dp</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">plot_marker</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">permanent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.scattering_params">
<span id="pyxem-utils-scattering-params-module"></span><h2>pyxem.utils.scattering_params module<a class="headerlink" href="#module-pyxem.utils.scattering_params" title="Permalink to this headline">¶</a></h2>
<p>Scattering Paramaters as Tabulated in
“Advanced Computing in Electron Microscopy - Second Edition (2010) - Earl.J.Kirkland”
ISBN 978-1-4419-6532-5
Pages 253-260 Appendix C</p>
<p>This transcription comes from scikit-ued (MIT license) - <a class="reference external" href="https://pypi.python.org/pypi/scikit-ued">https://pypi.python.org/pypi/scikit-ued</a></p>
</div>
<div class="section" id="module-pyxem.utils.sim_utils">
<span id="pyxem-utils-sim-utils-module"></span><h2>pyxem.utils.sim_utils module<a class="headerlink" href="#module-pyxem.utils.sim_utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.sim_utils.get_atomic_scattering_factors">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_atomic_scattering_factors</code><span class="sig-paren">(</span><em>g_hkl_sq</em>, <em>coeffs</em>, <em>scattering_params</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_atomic_scattering_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate atomic scattering factors for n atoms.</p>
<dl class="simple">
<dt>g_hkl_sq<span class="classifier">ndarray</span></dt><dd><p>One-dimensional array of g-vector lengths squared.</p>
</dd>
<dt>coeffs<span class="classifier">ndarray</span></dt><dd><p>Three-dimensional array [n, 5, 2] of coefficients corresponding to the n atoms.</p>
</dd>
<dt>scattering_params<span class="classifier">string</span></dt><dd><p>Type of scattering factor calculation to use. One of ‘lobato’, ‘xtables’.</p>
</dd>
</dl>
<dl class="simple">
<dt>scattering_factors<span class="classifier">ndarray</span></dt><dd><p>The calculated atomic scattering parameters.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_electron_wavelength">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_electron_wavelength</code><span class="sig-paren">(</span><em>accelerating_voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_electron_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the (relativistic) electron wavelength in Angstroms for a
given accelerating voltage in kV.</p>
<dl class="simple">
<dt>accelerating_voltage<span class="classifier">float</span></dt><dd><p>The accelerating voltage in kV.</p>
</dd>
</dl>
<dl class="simple">
<dt>wavelength<span class="classifier">float</span></dt><dd><p>The relativistic electron wavelength in Angstroms.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_interaction_constant">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_interaction_constant</code><span class="sig-paren">(</span><em>accelerating_voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_interaction_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the interaction constant, sigma, for a given
acelerating voltage.</p>
<dl class="simple">
<dt>accelerating_voltage<span class="classifier">float</span></dt><dd><p>The accelerating voltage in V.</p>
</dd>
</dl>
<dl class="simple">
<dt>sigma<span class="classifier">float</span></dt><dd><p>The relativistic electron wavelength in m.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_kinematical_intensities">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_kinematical_intensities</code><span class="sig-paren">(</span><em>structure</em>, <em>g_indices</em>, <em>g_hkls</em>, <em>excitation_error</em>, <em>maximum_excitation_error</em>, <em>debye_waller_factors</em>, <em>scattering_params='lobato'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_kinematical_intensities" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates peak intensities.</p>
<p>The peak intensity is a combination of the structure factor for a given
peak and the position the Ewald sphere intersects the relrod. In this
implementation, the intensity scales linearly with proximity.</p>
<dl class="simple">
<dt>structure<span class="classifier">Structure</span></dt><dd><p>The structure for which to derive the structure factors.</p>
</dd>
<dt>indices<span class="classifier">array-like</span></dt><dd><p>The fractional coordinates of the peaks for which to calculate the
structure factor.</p>
</dd>
<dt>proximities<span class="classifier">array-like</span></dt><dd><p>The distances between the Ewald sphere and the peak centers.</p>
</dd>
</dl>
<dl class="simple">
<dt>peak_intensities<span class="classifier">array-like</span></dt><dd><p>The intensities of the peaks.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_points_in_sphere">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_points_in_sphere</code><span class="sig-paren">(</span><em>reciprocal_lattice</em>, <em>reciprocal_radius</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_points_in_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all reciprocal lattice points inside a given reciprocal sphere.
Utilised within the DiffractionGenerator.</p>
<dl class="simple">
<dt>reciprocal_lattice<span class="classifier">diffpy.Structure.Lattice</span></dt><dd><p>The crystal lattice for the structure of interest.
TODO: Mention that it is the reciprocal lattice. Just take the structure and calculate from there?</p>
</dd>
<dt>reciprocal_radius<span class="classifier">float</span></dt><dd><p>The radius of the sphere in reciprocal space (units of reciprocal
Angstroms) within which reciprocal lattice points are returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>spot_indicies<span class="classifier">numpy.array</span></dt><dd><p>Miller indices of reciprocal lattice points in sphere.</p>
</dd>
<dt>spot_coords<span class="classifier">numpy.array</span></dt><dd><p>Cartesian coordinates of reciprocal lattice points in sphere.</p>
</dd>
<dt>spot_distances<span class="classifier">numpy.array</span></dt><dd><p>Distance of reciprocal lattice points in sphere from the origin.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_scattering_params_dict">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_scattering_params_dict</code><span class="sig-paren">(</span><em>scattering_params</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_scattering_params_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Get scattering parameter dictionary from name.</p>
<dl class="simple">
<dt>scattering_params<span class="classifier">string</span></dt><dd><p>Name of scattering factors. One of ‘lobato’, ‘xtables’.</p>
</dd>
</dl>
<dl class="simple">
<dt>scattering_params_dict<span class="classifier">dict</span></dt><dd><p>Dictionary of scattering parameters mapping from element name.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_unique_families">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_unique_families</code><span class="sig-paren">(</span><em>hkls</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_unique_families" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique families of Miller indices, which must be permutations of
each other.</p>
<dl class="simple">
<dt>hkls<span class="classifier">list</span></dt><dd><p>List of Miller indices ([h, k, l])</p>
</dd>
</dl>
<dl class="simple">
<dt>pretty_unique<span class="classifier">dictionary</span></dt><dd><p>A dict with unique hkl and multiplicity {hkl: multiplicity}.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.get_vectorized_list_for_atomic_scattering_factors">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">get_vectorized_list_for_atomic_scattering_factors</code><span class="sig-paren">(</span><em>structure</em>, <em>debye_waller_factors</em>, <em>scattering_params</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.get_vectorized_list_for_atomic_scattering_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a flattened array of coeffs, fcoords and occus for vectorized
computation of atomic scattering factors.</p>
<p>Note: The dimensions of the returned objects are not necessarily the same
size as the number of atoms in the structure as each partially occupied
specie occupies its own position in the flattened array.</p>
<dl class="simple">
<dt>structure<span class="classifier">diffpy.structure</span></dt><dd><p>The atomic structure for which scattering factors are required.</p>
</dd>
<dt>debye_waller_factors<span class="classifier">list</span></dt><dd><p>List of Debye-Waller factors for atoms in structure.</p>
</dd>
</dl>
<dl class="simple">
<dt>coeffs<span class="classifier">np.array()</span></dt><dd><p>Coefficients of atomic scattering factor parameterization for each atom.</p>
</dd>
<dt>fcoords<span class="classifier">np.array()</span></dt><dd><p>Fractional coordinates of each atom in structure.</p>
</dd>
<dt>occus<span class="classifier">np.array()</span></dt><dd><p>Occupancy of each atomic site.</p>
</dd>
<dt>dwfactors<span class="classifier">np.array()</span></dt><dd><p>Debye-Waller factors for each atom in the structure.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.is_lattice_hexagonal">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">is_lattice_hexagonal</code><span class="sig-paren">(</span><em>latt</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.is_lattice_hexagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if a diffpy lattice is hexagonal or trigonal.</p>
<dl class="simple">
<dt>latt<span class="classifier">diffpy.Structure.lattice</span></dt><dd><p>The diffpy lattice object to be determined as hexagonal or not.</p>
</dd>
</dl>
<dl class="simple">
<dt>is_true<span class="classifier">bool</span></dt><dd><p>True if hexagonal or trigonal.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.peaks_from_best_template">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">peaks_from_best_template</code><span class="sig-paren">(</span><em>single_match_result</em>, <em>library</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.peaks_from_best_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a TemplateMatchingResults object and return the associated peaks,
to be used in combination with map().</p>
<dl class="simple">
<dt>single_match_result<span class="classifier">ndarray</span></dt><dd><p>An entry in a TemplateMatchingResults.</p>
</dd>
<dt>library<span class="classifier">DiffractionLibrary</span></dt><dd><p>Diffraction library containing the phases and rotations.</p>
</dd>
</dl>
<dl class="simple">
<dt>peaks<span class="classifier">array</span></dt><dd><p>Coordinates of peaks in the matching results object in calibrated units.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.peaks_from_best_vector_match">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">peaks_from_best_vector_match</code><span class="sig-paren">(</span><em>single_match_result</em>, <em>library</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.peaks_from_best_vector_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a VectorMatchingResults object and return the associated peaks,
to be used in combination with map().</p>
<dl class="simple">
<dt>single_match_result<span class="classifier">ndarray</span></dt><dd><p>An entry in a VectorMatchingResults</p>
</dd>
<dt>library<span class="classifier">DiffractionLibrary</span></dt><dd><p>Diffraction library containing the phases and rotations</p>
</dd>
</dl>
<dl class="simple">
<dt>peaks<span class="classifier">ndarray</span></dt><dd><p>Coordinates of peaks in the matching results object in calibrated units.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.rotation_list_stereographic">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">rotation_list_stereographic</code><span class="sig-paren">(</span><em>structure</em>, <em>corner_a</em>, <em>corner_b</em>, <em>corner_c</em>, <em>inplane_rotations</em>, <em>resolution</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.rotation_list_stereographic" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a rotation list covering the inverse pole figure specified by
three corners in cartesian coordinates.</p>
<dl>
<dt>structure<span class="classifier">diffpy.structure.Structure</span></dt><dd><p>Structure for which to calculate the rotation list.</p>
</dd>
<dt>corner_a, corner_b, corner_c<span class="classifier">tuple</span></dt><dd><p>The three corners of the inverse pole figure, each given by a
three-dimensional coordinate. The coordinate system is given by the
structure lattice.</p>
</dd>
<dt>resolution<span class="classifier">float</span></dt><dd><p>Angular resolution in radians of the generated rotation list.</p>
</dd>
<dt>inplane_rotations<span class="classifier">list</span></dt><dd><p>List of angles in radians for in-plane rotation of the diffraction
pattern. This corresponds to the third Euler angle rotation. The
rotation list will be generated for each of these angles, and combined.
This should be done automatically, but by including all possible
rotations in the rotation list, it becomes too large.</p>
<p>To cover all inplane rotations, use e.g. np.linspace(0, 2*np.pi, 360).</p>
</dd>
</dl>
<dl class="simple">
<dt>rotation_list<span class="classifier">numpy.array</span></dt><dd><p>Rotations covering the inverse pole figure given as an array of Euler
angles in degrees.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.simulate_kinematic_scattering">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">simulate_kinematic_scattering</code><span class="sig-paren">(</span><em>atomic_coordinates</em>, <em>element</em>, <em>accelerating_voltage</em>, <em>simulation_size=256</em>, <em>max_k=1.5</em>, <em>illumination='plane_wave'</em>, <em>sigma=20</em>, <em>scattering_params='lobato'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.simulate_kinematic_scattering" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate electron scattering from arrangement of atoms comprising one
elemental species.</p>
<dl class="simple">
<dt>atomic_coordinates<span class="classifier">array</span></dt><dd><p>Array specifying atomic coordinates in structure.</p>
</dd>
<dt>element<span class="classifier">string</span></dt><dd><p>Element symbol, e.g. “C”.</p>
</dd>
<dt>accelerating_voltage<span class="classifier">float</span></dt><dd><p>Accelerating voltage in keV.</p>
</dd>
<dt>simulation_size<span class="classifier">int</span></dt><dd><p>Simulation size, n, specifies the n x n array size for
the simulation calculation.</p>
</dd>
<dt>max_k<span class="classifier">float</span></dt><dd><p>Maximum scattering vector magnitude in reciprocal angstroms.</p>
</dd>
<dt>illumination<span class="classifier">string</span></dt><dd><p>Either ‘plane_wave’ or ‘gaussian_probe’ illumination</p>
</dd>
<dt>sigma<span class="classifier">float</span></dt><dd><p>Gaussian probe standard deviation, used when illumination == ‘gaussian_probe’</p>
</dd>
<dt>scattering_params<span class="classifier">string</span></dt><dd><p>Type of scattering factor calculation to use. One of ‘lobato’, ‘xtables’.</p>
</dd>
</dl>
<dl class="simple">
<dt>simulation<span class="classifier">ElectronDiffraction</span></dt><dd><p>ElectronDiffraction simulation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.simulate_rotated_structure">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">simulate_rotated_structure</code><span class="sig-paren">(</span><em>diffraction_generator</em>, <em>structure</em>, <em>rotation_matrix</em>, <em>reciprocal_radius</em>, <em>with_direct_beam</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.simulate_rotated_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate electron diffraction data for a structure after rotating it.</p>
<dl class="simple">
<dt>diffraction_generator<span class="classifier">DiffractionGenerator</span></dt><dd><p>Diffraction generator used to simulate diffraction patterns</p>
</dd>
<dt>structure<span class="classifier">diffpy.structure.Structure</span></dt><dd><p>Structure object to simulate</p>
</dd>
<dt>rotation_matrix<span class="classifier">ndarray</span></dt><dd><p>3x3 matrix describing the base rotation to apply to the structure</p>
</dd>
<dt>reciprocal_radius<span class="classifier">float</span></dt><dd><p>The maximum g-vector magnitude to be included in the simulations.</p>
</dd>
<dt>with_direct_beam<span class="classifier">bool</span></dt><dd><p>Include the direct beam peak</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.transfer_navigation_axes">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">transfer_navigation_axes</code><span class="sig-paren">(</span><em>new_signal</em>, <em>old_signal</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.transfer_navigation_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfers navigation axis calibrations from an old signal to a new
signal produced from it by a method or a generator.</p>
<dl class="simple">
<dt>new_signal<span class="classifier">Signal</span></dt><dd><p>The product signal with undefined navigation axes.</p>
</dd>
<dt>old_signal<span class="classifier">Signal</span></dt><dd><p>The parent signal with calibrated navigation axes.</p>
</dd>
</dl>
<dl class="simple">
<dt>new_signal<span class="classifier">Signal</span></dt><dd><p>The new signal with calibrated navigation axes.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.transfer_navigation_axes_to_signal_axes">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">transfer_navigation_axes_to_signal_axes</code><span class="sig-paren">(</span><em>new_signal</em>, <em>old_signal</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.transfer_navigation_axes_to_signal_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfers navigation axis calibrations from an old signal to the signal
axes of a new signal produced from it by a method or a generator.</p>
<p>Used from methods that generate a signal with a single value at each
navigation position.</p>
<dl class="simple">
<dt>new_signal<span class="classifier">Signal</span></dt><dd><p>The product signal with undefined navigation axes.</p>
</dd>
<dt>old_signal<span class="classifier">Signal</span></dt><dd><p>The parent signal with calibrated navigation axes.</p>
</dd>
</dl>
<dl class="simple">
<dt>new_signal<span class="classifier">Signal</span></dt><dd><p>The new signal with calibrated signal axes.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.sim_utils.uvtw_to_uvw">
<code class="descclassname">pyxem.utils.sim_utils.</code><code class="descname">uvtw_to_uvw</code><span class="sig-paren">(</span><em>uvtw</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.sim_utils.uvtw_to_uvw" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert 4-index direction to a 3-index direction.</p>
<p>uvtw : array-like with 4 floats</p>
<p>uvw : tuple of 4 floats</p>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.subpixel_refinements_utils">
<span id="pyxem-utils-subpixel-refinements-utils-module"></span><h2>pyxem.utils.subpixel_refinements_utils module<a class="headerlink" href="#module-pyxem.utils.subpixel_refinements_utils" title="Permalink to this headline">¶</a></h2>
<p>utils to support SubpixelrefinementGenerator</p>
<dl class="function">
<dt id="pyxem.utils.subpixel_refinements_utils.get_experimental_square">
<code class="descclassname">pyxem.utils.subpixel_refinements_utils.</code><code class="descname">get_experimental_square</code><span class="sig-paren">(</span><em>z</em>, <em>vector</em>, <em>square_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.subpixel_refinements_utils.get_experimental_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a square region around a given diffraction vector and returns an
upsampled copy.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Single diffraction pattern</p>
</dd>
<dt>vector<span class="classifier">np.array()</span></dt><dd><p>Single vector in pixels (int) [x,y] with top left as [0,0]</p>
</dd>
<dt>square_size<span class="classifier">int</span></dt><dd><p>The length of one side of the bounding square (must be even)</p>
</dd>
</dl>
<dl class="simple">
<dt>square<span class="classifier">np.array()</span></dt><dd><p>Of size (L,L) where L = square_size</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.subpixel_refinements_utils.get_simulated_disc">
<code class="descclassname">pyxem.utils.subpixel_refinements_utils.</code><code class="descname">get_simulated_disc</code><span class="sig-paren">(</span><em>square_size</em>, <em>disc_radius</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.subpixel_refinements_utils.get_simulated_disc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a uniform disc for correlating with the experimental square.</p>
<dl class="simple">
<dt>square size<span class="classifier">int</span></dt><dd><p>(even) - size of the bounding box</p>
</dd>
<dt>disc_radius<span class="classifier">int</span></dt><dd><p>radius of the disc</p>
</dd>
</dl>
<dl class="simple">
<dt>arr: np.array()</dt><dd><p>Upsampled copy of the simulated disc as a numpy array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.vdf_utils">
<span id="pyxem-utils-vdf-utils-module"></span><h2>pyxem.utils.vdf_utils module<a class="headerlink" href="#module-pyxem.utils.vdf_utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.vdf_utils.normalize_vdf">
<code class="descclassname">pyxem.utils.vdf_utils.</code><code class="descname">normalize_vdf</code><span class="sig-paren">(</span><em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vdf_utils.normalize_vdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes image intensity by dividing by maximum value.</p>
<dl class="simple">
<dt>im<span class="classifier">np.array()</span></dt><dd><p>Array of image intensities</p>
</dd>
</dl>
<dl class="simple">
<dt>imn<span class="classifier">np.array()</span></dt><dd><p>Array of normalized image intensities</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils.vector_utils">
<span id="pyxem-utils-vector-utils-module"></span><h2>pyxem.utils.vector_utils module<a class="headerlink" href="#module-pyxem.utils.vector_utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pyxem.utils.vector_utils.calculate_norms">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">calculate_norms</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.calculate_norms" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the norm of an array of cartesian vectors. For use with map().</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Array of cartesian vectors.</p>
</dd>
</dl>
<dl class="simple">
<dt>norms<span class="classifier">np.array()</span></dt><dd><p>Array of vector norms.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.vector_utils.calculate_norms_ragged">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">calculate_norms_ragged</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.calculate_norms_ragged" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the norm of an array of cartesian vectors. For use with map()
when applied to a ragged array.</p>
<dl class="simple">
<dt>z<span class="classifier">np.array()</span></dt><dd><p>Array of cartesian vectors.</p>
</dd>
</dl>
<dl class="simple">
<dt>norms<span class="classifier">np.array()</span></dt><dd><p>Array of vector norms.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.vector_utils.detector_to_fourier">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">detector_to_fourier</code><span class="sig-paren">(</span><em>k_xy</em>, <em>wavelength</em>, <em>camera_length</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.detector_to_fourier" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps two-dimensional Cartesian coordinates in the detector plane to
three-dimensional coordinates in reciprocal space, with origo in [000].</p>
<p>The detector uses a left-handed coordinate system, while the reciprocal
space uses a right-handed coordinate system.</p>
<dl class="simple">
<dt>k_xy<span class="classifier">np.array()</span></dt><dd><p>Cartesian coordinates in detector plane, in reciprocal Ångström.</p>
</dd>
<dt>wavelength<span class="classifier">float</span></dt><dd><p>Electron wavelength in Ångström.</p>
</dd>
<dt>camera_length<span class="classifier">float</span></dt><dd><p>Camera length in metres.</p>
</dd>
</dl>
<dl class="simple">
<dt>k<span class="classifier">np.array()</span></dt><dd><p>Array of Cartesian coordinates in reciprocal space relative to [000].</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.vector_utils.get_angle_cartesian">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">get_angle_cartesian</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.get_angle_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the angle between two vectors in a cartesian coordinate system.</p>
<dl class="simple">
<dt>a, b<span class="classifier">array-like with 3 floats</span></dt><dd><p>The two directions to compute the angle between.</p>
</dd>
</dl>
<dl class="simple">
<dt>angle<span class="classifier">float</span></dt><dd><p>Angle between <cite>a</cite> and <cite>b</cite> in radians.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.vector_utils.get_indices_from_distance_matrix">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">get_indices_from_distance_matrix</code><span class="sig-paren">(</span><em>distances</em>, <em>distance_threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.get_indices_from_distance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the distances from one vector in vlist to all other vectors in
vlist are larger than distance_threshold.</p>
<dl class="simple">
<dt>distances<span class="classifier">np.array()</span></dt><dd><p>Array of distances between vectors.</p>
</dd>
<dt>distance_threshold<span class="classifier">float</span></dt><dd><p>The distance threshold for a vector to be retained.</p>
</dd>
</dl>
<dl class="simple">
<dt>new_indices<span class="classifier">np.array()</span></dt><dd><p>Array of vectors with distances greater than the threshold.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.vector_utils.get_npeaks">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">get_npeaks</code><span class="sig-paren">(</span><em>found_peaks</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.get_npeaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of entries in a list. For use with map().</p>
<dl class="simple">
<dt>found_peaks<span class="classifier">np.array()</span></dt><dd><p>Array of found peaks.</p>
</dd>
</dl>
<dl class="simple">
<dt>len<span class="classifier">int</span></dt><dd><p>The number of peaks in the array.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyxem.utils.vector_utils.get_rotation_matrix_between_vectors">
<code class="descclassname">pyxem.utils.vector_utils.</code><code class="descname">get_rotation_matrix_between_vectors</code><span class="sig-paren">(</span><em>k1</em>, <em>k2</em>, <em>ref_k1</em>, <em>ref_k2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyxem.utils.vector_utils.get_rotation_matrix_between_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotation matrix to two experimentally measured
diffraction vectors from the corresponding vectors in a reference structure.</p>
<dl class="simple">
<dt>k1<span class="classifier">np.array()</span></dt><dd><p>Experimentally measured scattering vector 1.</p>
</dd>
<dt>k2<span class="classifier">np.array()</span></dt><dd><p>Experimentally measured scattering vector 2.</p>
</dd>
<dt>ref_k1<span class="classifier">np.array()</span></dt><dd><p>Reference scattering vector 1.</p>
</dd>
<dt>ref_k2<span class="classifier">np.array()</span></dt><dd><p>Reference scattering vector 2.</p>
</dd>
</dl>
<dl class="simple">
<dt>R<span class="classifier">np.array()</span></dt><dd><p>Rotation matrix describing transformation from experimentally measured
scattering vectors to equivalent reference vectors.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pyxem.utils">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyxem.utils" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pyxem</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Duncan Johnstone.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/pyxem.utils.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>